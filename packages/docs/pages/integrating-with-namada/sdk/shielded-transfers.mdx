import { Callout } from "nextra-theme-docs";

# Shielded Transfers

You can construct shielded transfers similarly to transparent transfers, except
that rather than providing implicit addresses as the `source` and `target`, you
will need to provide a spending key and payment address, respectively.

Before building your transaction, you will want to make sure the
[shielded wallet is synced](./shielded-sync.mdx).

### Constructing the Transfer

This example assumes you have a spending key with sufficient shielded balance, a
recipient payment address, and the public key of an implicit account with gas
funds.

```rust
use namada_sdk::Namada;
use namada_sdk::args::TxShieldedTransferData;
use namada_sdk::masp::PaymentAddress;
use namada_sdk::signing::default_sign;

async fn construct_transfer(sdk: impl Namada) {
    let spend_key = ExtendedSpendingKey::from_str("zsknam1q0medj45qqqqpq9wh90qd9c7d9f7n5xxn89h6dl54k0jfmucwn4yk7nykxwcrjmk4ylkdnlnn3wkkd9f3ul3nyw8hv5wlsfgklzr5ghzk2spzzwm05csvl2s3rn0aq7f9w4z7guul682yrw4hsmren2k2lgdp003uuj00lsd8nlevc8n32sz6j350up209980c04qdqcu97vh5476xv423k6jp58qn7hqjf9nvsvk8p8g5yfmqguu039q34c2euzhcpnca7vpp4pelqu6y87k")
      .expect("Invalid spending key");
    let payment_addr = PaymentAddress::from_str("znam1vsz9wsge4u9c0thh38vhn2z9awzfqn4540ue4haxmcxl43srptrgrtlhn6r9cd9razawuakcclc")
      .expect("Invalid payment address");

    sdk.shielded_mut().await.load().await.expect("Could not load shielded context");

    // specify the transfer arguments
    let data = TxShieldedTransferData {
      source: spend_key,
      target: payment_addr,
      token: sdk.native_token(),
      amount: InputAmount::from_str("5").expect("Invalid amount"),
    };

    // build the tx
    let mut transfer_tx_builder = sdk
      .new_shielded_transfer(
        vec![data],
        vec![spend_key]
      )
      .wrapper_fee_payer(alice_acct.public_key.clone());

    let (mut transfer_tx, signing_data) = transfer_tx_builder
      .build(&sdk)
      .await
      .expect("Unable to build transfer tx");

    // sign the tx
    sdk.sign(&mut transfer_tx, &transfer_tx_builder.tx, signing_data, default_sign, ())
      .await
      .expect("unable to sign transfer tx");

    // submit tx to the chain
    match sdk.submit(transfer_tx, &transfer_tx_builder.tx).await {
      Ok(res) => println!("Tx result: {:?}", res),
      Err(e) => println!("Tx error: {:?}", e)
    }
}
```

### Frontend sustainability fee

For transactions that move assets into or out of the shielded pool, the namada
SDK provides the possibility to charge an optional fee to support the operations
of the frontend provider. The specific transactions are:

- `TxShieldingTransfer`
- `TxUnshieldingTransfer`
- `TxOsmosisSwap`
- `TxIbcTransfer`
- `GenIbcShieldingTransfer`

<Callout type="warning">
  For fully shielded osmosis swaps (from shieleded address to shielded address),
  the operator should refrain from charging a fee as the unshielding and
  reshielding operations are only needed to perform the swap but the value
  inside the shielded pool remains unchanged.
</Callout>

These structures provide an optional field in one of two forms:

```rust
  pub frontend_sus_fee: Option<(C::TransferTarget, Dec)>,
  pub frontend_sus_fee: Option<(C::PaymentAddress, Dec)>,
```

where the first element of the tuple is the receiver of the fee (an address
controlled by the operator) and the second one is the fee expressed as a
percentage of the shielded/unshielded amount. By providing a value for this
field, the SDK builder for the desired transaction will inject extra inputs (one
for every source address) and an extra output to the transfer data (no batching
required): more specifically, the provided percentage will be taken from every
transfer's source on top of the amount specified by the user and sent to the
provided target address. Whether these extra inputs/output are shielded or
transparent depends on the specific transaction and its sources: when the
transaction's source is transparent an extra trasparent input will be added to
the `Transfer` data, whereas if the input is shielded another shieleded input
will be added to the MASP `Transaction` section. The output can either be
shielded or transparent when the above `frontend_sus_fee` specifies it via the
`C::TransferTarget` type. For the `TxOsmosisSwap` and `GenIbcShieldingTransfer`
transactions instead, the fee target can be specified only as a shielded payment
address.

The user will accept this fee when signing the transaction since this
information will be available to them for review and acceptance at that time.
